<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SVG with Curved Lines</title>
<style>
    .draggable {
        cursor: move;
    }
</style>
</head>
<body>
<svg id="svgContainer" width="600" height="400" viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg"></svg>

<script>
function createSVGElement(type, attributes) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", type);
    for (const key in attributes) {
        element.setAttribute(key, attributes[key]);
    }
    return element;
}

function drawBoxes(svg, boxes) {
    boxes.forEach(function(box, index) {
        const rect = createSVGElement("rect", {
            x: box.x,
            y: box.y,
            width: box.width,
            height: box.height,
            fill: box.fillColor,
            stroke: "#000",
            "stroke-width": "2",
            class: "draggable",
            "data-index": index
        });
        svg.appendChild(rect);
    });
}

function calculateControlPoints(startX, startY, endX, endY) {
    const controlX1 = startX + 40,
        controlY1 = startY,
        controlX2 = endX - 40,
        controlY2 = endY;
    return { controlX1, controlY1, controlX2, controlY2 };
}

function drawCurvedLines(svg, boxes) {
    const lines = [];
    for (let i = 0; i < boxes.length - 1; i++) {               
        const line = createSVGElement("path", {
            fill: "none",
            stroke: "#000",
            "stroke-width": "2"
        });
        svg.appendChild(line);
        lines.push({ line, controlX1: 1, controlY1: 1, controlX2: 1, controlY2: 1 });
    }
    updateCurvedLines(boxes, lines);	
    return lines;
}

function updateCurvedLines(boxes, lines) {
    for (let i = 0; i < boxes.length - 1; i++) {
        const startX = boxes[i].x + boxes[i].width,
            startY = boxes[i].y + boxes[i].height / 2,
            endX = boxes[i + 1].x,
            endY = boxes[i + 1].y + boxes[i + 1].height / 2;
        
        const controlPoints = calculateControlPoints(startX, startY, endX, endY),
            { controlX1, controlY1, controlX2, controlY2 } = controlPoints;
        
        const lineData = lines[i];
        const pathString = `M${startX},${startY} C${controlX1},${controlY1} ${controlX2},${controlY2} ${endX},${endY}`;
        lineData.line.setAttribute("d", pathString);
        Object.assign(lineData, { controlX1, controlY1, controlX2, controlY2 });
    }
}

function drawSVGWithCurvedLines(svgContainerId, boxes) {
    const svg = document.getElementById(svgContainerId);
    drawBoxes(svg, boxes);
    const lines = drawCurvedLines(svg, boxes);
    return lines;
}

const boxes = [
    {x: 50, y: 50, width: 100, height: 50, fillColor: "#ffcc00"},
    {x: 250, y: 100, width: 100, height: 50, fillColor: "#ccff00"},
    {x: 150, y: 150, width: 100, height: 50, fillColor: "#00ccff"}
];
const lines = drawSVGWithCurvedLines("svgContainer", boxes);

let selectedElement = null,
    offset = { x: 0, y: 0 };

function startDragging(evt) {
    if (evt.target.classList.contains("draggable")) {
        selectedElement = evt.target;
        offset.x = evt.clientX - selectedElement.getAttribute("x");
        offset.y = evt.clientY - selectedElement.getAttribute("y");
    }
}

function drag(evt) {
    if (selectedElement) {
        const newX = evt.clientX - offset.x,
            newY = evt.clientY - offset.y;
        selectedElement.setAttribute("x", newX);
        selectedElement.setAttribute("y", newY);
        
        const boxIndex = parseInt(selectedElement.getAttribute("data-index"));
        boxes[boxIndex].x = newX;
        boxes[boxIndex].y = newY;
        
        updateCurvedLines(boxes, lines);
    }
}

function endDragging(evt) {
    selectedElement = null;
}

document.addEventListener("mousedown", startDragging);
document.addEventListener("mousemove", drag);
document.addEventListener("mouseup", endDragging);
</script>
</body>
</html>
